//----------------------
// <auto-generated>
// </auto-generated>
//----------------------







export abstract class Base implements IBase {

    protected _discriminator: string;

    constructor(data?: IBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        this._discriminator = "Base";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Base {
        data = typeof data === 'object' ? data : {};
        if (data["Type"] === "OneChild") {
            let result = new OneChild();
            result.init(data);
            return result;
        }
        if (data["Type"] === "SecondChild") {
            let result = new SecondChild();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Base' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Type"] = this._discriminator;
        return data;
    }
}

export interface IBase {
}

export class OneChild extends Base implements IOneChild {
    a: string;
    type: EBase;

    constructor(data?: IOneChild) {
        super(data);
        this._discriminator = "OneChild";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.a = _data["A"];
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): OneChild {
        data = typeof data === 'object' ? data : {};
        let result = new OneChild();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["A"] = this.a;
        data["Type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IOneChild extends IBase {
    a: string;
    type: EBase;
}

export enum EBase {
    OneChild = "OneChild",
    SecondChild = "SecondChild",
}

export class SecondChild extends Base implements ISecondChild {
    b: string;
    type: EBase;

    constructor(data?: ISecondChild) {
        super(data);
        this._discriminator = "SecondChild";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.b = _data["B"];
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): SecondChild {
        data = typeof data === 'object' ? data : {};
        let result = new SecondChild();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["B"] = this.b;
        data["Type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface ISecondChild extends IBase {
    b: string;
    type: EBase;
}

export class MyClass implements IMyClass {
    child: OneChild | SecondChild;
    children: (OneChild | SecondChild)[];

    constructor(data?: IMyClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.child = _data["Child"] ? OneChild | SecondChild.fromJS(_data["Child"]) : undefined as any;
            if (Array.isArray(_data["Children"])) {
                this.children = [] as any;
                for (let item of _data["Children"])
                    this.children.push(OneChild | SecondChild.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MyClass {
        data = typeof data === 'object' ? data : {};
        let result = new MyClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Child"] = this.child ? this.child.toJSON() : undefined as any;
        if (Array.isArray(this.children)) {
            data["Children"] = [];
            for (let item of this.children)
                data["Children"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IMyClass {
    child: OneChild | SecondChild;
    children: (OneChild | SecondChild)[];
}